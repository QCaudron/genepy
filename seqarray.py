import genepy

import numpy as np
import matplotlib.pyplot as plt
import os
from Bio import SeqRecord





# NEXT TIME :
# Two errors to deal with :
# - Err.: one or more missing sequences in block 2
# --- solutions - Guindon ?
# --- solutions - read .phy generated by ClustalO, and rewrite it using BioPython
# - Duplicate names in PHYLIP files due to truncation. Way around ?

# .remove() - remove some sequences from the array









# Base sequence list class
class seqarray :
	"""GenePy Sequence Array object.
	For documentation, see http://github.io/QCaudron/genepy
	"""











	def __init__(self, source) :
		"""Constructor. 

		Argument : a filename or a list of strings that represent sequences.

		- mysequences = genepy.seqarray("from_genbank.gb") -- loads the sequences
		in from_genbank.gb as BioPython Bio.Seq objects.
		- mysequences = genepy.seqarray(seq_list), where seq_list is a list of 
		strings ( such as ["ACTG", "AGTA", "TTGC"] ) converts these to BioPython
		Bio.Seq objects using the generic_dna alphabet ( for now ).
		""" 

		# If we're reading in a sequence set from a file
		if type(source) is str :
			if os.path.isfile(source) :
				self.seq = genepy.readalignment(source)
				self.filename = source
			else :
				print "%s not found, aborting." % source

		# If we're fed a list
		elif type(source) is list :
			self.seq = [SeqRecord.SeqRecord(s) for s in source]
			self.filename = "genepy.fasta"

		else :
			raise TypeError("Expected a filename or a list of strings.")


		# User-run operations
		self.user = { "Aligned" : False,
				 	  "Trimmed" : False }

		# Generate static members
		self.update()
		

















	def __str__(self) :
		"""Long string representation of a genepy.seqarray object."""
		out = self.__repr__()
		out += ("\n-- C+G content : %.03f" % (self.statistics["C"].mean() + self.statistics["G"].mean()))
		out += ("\n-- From file : %s" % self.filename.split("/")[-1])
		out += ("\n-- User aligned : %r" % self.user["Aligned"])
		out += ("\n-- User trimmed : %r" % self.user["Trimmed"])
		return out




















	def __repr__(self) :
		"""Short string representation of a genepy.seqarray object."""
		summary = "GenePy sequence array (genepy.seqarray) :\n"
		summary += "-- Sequences : %d\n" % self.len
		summary += "-- Mean length : %.01f (min %d, max %d)\n" % \
			(np.array(self.seq_len).mean(), np.min(self.seq_len), np.max(self.seq_len))

		return summary





















	def __iter__(self) :
		"""Iterator function."""
		self.iter = 0
		return self



	def next(self) :
		"""Next object in iteration."""
		if self.iter == self.len :
			raise StopIteration
		else :
			self.iter += 1
			return self.seq[self.iter - 1]















	def update(self) :
		"""Updates the member variables of a genepy.seqarray object.

		This function is called whenever sequences are aligned or trimmed.
		Any changes made directly to genepy.seqarray variables ( such as to the 
		sequence list, genepy.seqarray.seq ), will not be reflected in other
		member variables ( such as genepy.seqarray.len ) until this function
		is called. In general, as long as the user calls genepy.seqarray methods
		only, and no changes are otherwise made to the object, this method does
		not need to be used.
		"""

		# Number of sequences
		self.len = len(self.seq)

		# Sequence lengths
		self.seq_len = np.array([len(s.seq) for s in self.seq])

		# Alignment numerical array
		l = self.seq_len.max() if type(self.seq_len) == np.ndarray else self.seq_len
		self.array = genepy.alignmentarray(self.seq, length = l)

		# Statistics
		self.statistics = genepy.calcstats(self.seq)














	# Show sequences
	def show(self) :
		"""Display the sequences visually as a matplotlib.pyplot.imshow()

		Colours : 
		-- A : dark green
		-- C : dark red
		-- G : orange
		-- T : light green
		-- unknown / empty : black

		Cytosine and guanine are represented by "warm" colours; adenine and 
		thymine are shown in "cold" colours.
		"""
		genepy.showalignment(self.array)













	# Align sequences 
	def align(self, force = True, iter = False, full = False, full_iter = False, auto = True, threads = False) :
		"""Align the array of sequences using ClustalO.

		-- force : True / False; overwrite filename, if it exists
		-- iter : False, integers > 0; iterate the guide tree
		-- full : True / False; use full distance matrix for guide-tree calculation
		-- full_iter : True / False; use full distance matrix during iteration only
		-- auto : True / False; automatically select options for speed and accuracy
		-- threads : False, integers > 0; limit the number of threads; False uses all
		"""

		# System call to ClustalO
		genepy.align(self.filename, force, threads, full, full_iter, iter, auto)

		# Read alignment back in, rewrite it correctly for PhyML
		"""
		tempseq = []
		fin = open(self.filename.split(".")[0] + "_aligned_genepy.phy")
		
		for record in SeqIO.parse(fin, "phy") :
			tempseq.append(record.upper())
		fin.close()
		
		fout = open(self.filename.split(".")[0] + "_aligned_genepy.phy", "w")
		SeqIO.write(tempseq, fout)
		fout.close()
		"""
		self.seq = genepy.readalignment(self.filename.split(".")[0] + "_aligned_genepy.phy")

		self.user["Aligned"] = True
		
		# Update static members
		self.update()

















	def phylotree(self, nucleotide_frequency = "empirical", bootstrap = -4, search_algorithm = "BEST") :
		"""Construct a phylogenetic tree using PhyML.

		-- nucleotide_frequency : "empirical" or "max_likelihood"
		-- bootstrap : -4 for SH-like branch supports only; -2 for Chi^2;
		   -1 for approximate likelihood ratio; 0 for no bootstrapping,
		   integers > 0 for the number of bootstraps to perform, will try to use MPI
		-- search_algorithm : "NNI" for nearest-neighbour interchange; "SPR" for subtree
		   pruning and regrafting; "BEST" for best of both
		"""

		if not os.path.isfile(self.filename.split(".")[0] + "_aligned_genepy.phy") :
			print "GenePy can't find an aligned sequence file for %s.\nTry calling .align()." % \
			self.filename.split("/")[-1]

			return


		genepy.phylotree(self.filename, nucleotide_frequency, bootstrap, search_algorithm)
















	def stats(self) :
		"""Display sequence array statistics."""

		# Display statistics
		genepy.stats(self.statistics)














	def trimalignment(self, array = None, left = None, right = None) :
		"""Trim the sequence array by a given number of nucleotides from left and right.

		left, right : like performing mysequences.seq = mysequences.seq[left:right]
		"""

		self.seq = genepy.trimalignment(self.seq, array, left, right)
		self.user["Trimmed"] = True
		self.update()



